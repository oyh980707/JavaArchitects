# Java Architects

## 软件架构设计的七大原则

### 开闭原则

开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该**对**
**扩展开放，对修改关闭**。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调
的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开
闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，
例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。





## 设计模式

### 工厂模式(Factory Pattern)

#### 简单工厂模式

简单工厂模式（Simple Factory Pattern）是指由一个工厂对象决定创建出哪一种产品类的实例，但它不属于GOF，23种设计模式

简单工厂适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心

#### 工厂方法模式

工厂方法模式（Factory Method Pattern）是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符合开闭原则。

工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个课程的创建逻辑有区别的话，工厂的职责会变得越来越多，有点像万能工厂，并不便于维护。根据单一职责原则我们将职能继续拆分，专人干专事

工厂方法适用于以下场景

```text
- 创建对象需要大量重复的代码。
- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
- 一个类通过其子类来指定创建哪个对象。
```

工厂方法缺点

```text
- 类的个数容易过多，增加复杂度。
- 增加了系统的抽象性和理解难度
```

#### 抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

缺点

```text
- 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。
- 增加了系统的抽象性和理解难度。

ps:但在实际应用中，我们千万不能犯强迫症甚至有洁癖。在实际需求中产品等级结构升级是非常正常的一件事情。我们可以根据实际情况，只要不是频繁升级，可以不遵循开闭原则。代码每半年升级一次或者每年升级一次又有何不可呢？ 
```

### 单例模式(Singleton Pattern)

单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。

优点

```text
- 在内存中只有一个实例，减少了内存开销
- 可以避免对资源的多重占用
- 设置全局访问点，严格控制访问。
```

缺点

```text
- 没有接口，扩展困难
- 如果要扩展单例对象，只有修改代码，没有其他途径
```

一般创建单例的思路

```text
1、私有化构造器,隐藏其所有的构造方法
2、保证线程安全
3、延迟加载
4、防止序列化和反序列化破坏单例
5、防御反射攻击单例
```

#### 饿汉式单例

饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题。

优点

```text
没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。
```

缺点

```text
类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅坑不拉屎
```

#### 懒汉式单例

懒汉式单例(Lazy Singleton)被外部类调用的时候内部类才会加载

#### 反射破坏单例

单例模式的构造方法除了加上private以外，没有做任何处理。如果我们使用反射来调用其构造方法，然后，再调用getInstance()方法，应该就会两个不同的实例，所有即使私有化了构造方法，也要在构造方法中判断实例是否存在，如果存在就抛出异常

#### 序列化破坏单例

当我们将一个单例对象创建好，有时候需要将对象序列化然后写入到磁盘，下次使用时再从磁盘中读取到对象，反序列化转化为内存对象。反序列化后的对象会重新分配内存，即重新创建。那如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当于破坏了单例

#### 注册式单例

注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。注册式单例有两种写法：一种为容器缓存，一种为枚举登记。

#### ThreadLocal线程单例

ThreadLocal 不能保证其创建的对象是全局唯一，但是能保证在单个线程中是唯一的，天生的线程安全。

### 原型模式(Prototype Pattern)

原型模式是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象；调用者不需要知道任何创建细节，不调用构造函数。属于创建型模式

原型模式主要适用的场景

```text
- 类初始化消耗资源较多
- new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
- 构造函数比较复杂
- 循环体中生产大量对象时
```

#### 简单克隆

浅克隆：只是完整复制了值类型数据，没有赋值引用对象。换言之，所有的引用对象仍然指向原来的对象，显然不是我们想要的结果

#### 深度克隆

实现对象克隆有两种方式：

```text
- 实现Cloneable接口并重写Object类中的clone()方法；
- 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。
```

#### 克隆破坏单例模式

如果我们克隆的目标的对象是单例对象，那意味着，深克隆就会破坏单例

防止克隆破坏单例解决思路是禁止深克隆便可

```text
- 单例类不实现Cloneable接口
- 重写clone()方法，在clone方法中返回单例对象即可
```

### 代理模式(Proxy Pattern)

指为其他对象提供一种代理， 以控制对这个对象的访问。代理对象在客服端和目标对象之间起到中介作用。属于结构型设计模式。

适用场景

```text
- 保护目标对象
- 增强目标对象
```

代理模式的优点

```text
- 代理模式能将代理对象与真实被调用的目标对象分离
- 一定程度上降低了系统的耦合程度，易于扩展
- 代理可以起到保护目标对象的作用 
- 增强目标对象的职责
```

代理模式的缺点

```text
- 代理模式会造成系统设计中类的数目增加
- 在客户端和目标对象之间增加了一个代理对象，会造成请求处 理速度变慢
- 增加了系统的复杂度
```

#### 静态代理

显式声明被代理对象

#### 动态代理

动态配置和替换被代理对象

JDK动态代理的实现原理

```text
1、拿到被代理类的引用，并且获取它的所有的接口（反射获取）。
2、JDK Proxy类重新生成一个新的类，实现了被代理类所有接口的方法。
3、动态生成Java代码，把增强逻辑加入到新生成代码中。
4、编译生成新的Java代码的class文件。
5、加载并重新运行新的class，得到类就是全新类
```

CGLib动态代理容易踩的坑
1、无法代理final修饰的方法

CGLib和JDK动态代理对比

```text
1.JDK动态代理是实现了被代理对象的接口，CGLib是继承了 被代理对象。
2.JDK和CGLib都是在运行期生成字节码，JDK是直接写Class 字节码，CGLib使用ASM框架写Class字节码，Cglib代理实现 更复杂，生成代理类比JDK效率低。
3.JDK调用代理方法，是通过反射机制调用，CGLib是通过 FastClass机制直接调用方法，CGLib执行效率更高
```

#### 代理模式与Spring

Spring中的代理选择原则

```text
- 当Bean有实现接口时，Spring就会用JDK的动态代理。
- 当Bean没有实现接口时，Spring选择CGLib。
- Spring可以通过配置强制使用CGLib，只需在Spring的配 置文件中加入如下代码：
				<aop:aspectj-autoproxy proxy-target-class="true"/>
```









































































