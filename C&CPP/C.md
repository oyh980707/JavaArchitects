# C语言学习

C语言的编译过程

1. 代码预处理：编译器首先会移除源代码中的所有注释信息，并处理所有的宏指令。包括宏展开、宏替换、条件编译等等。
2. 编译优化：编译器会分析和优化源代码，并将其编译成对应的汇编代码。这部分代码中含有使用汇编指令描述的原始C程序逻辑。
3. 汇编：编译器将这些汇编指令代码编译成可以被操作系统使用的某种对象文件格式
4. 链接：通过连接处理，编译器会将目前需要进行整合的文件进行整合，设置好所有调用函数的正确地址，并生成对应的二进制可执行文件。

以上所有过程结束后，我们就得到可以直接运行的二进制文件。在不同的操作系统上，可以通过不同的方式来运行这个程序，双击或者命令行等等。

```c
#include <stdio.h>
int main(){
    int a = 0;
    printf("Hello Word!");
    return 0;
}
```
预处理
```shell
gcc -E hello.c -o hello.i
```
编译
```shell
gcc -S hello.i -o hello.s
```
汇编
```shell
gcc -c hello.s -o hello.o
```
链接
```shell
gcc hello.o -o hello
```

## C语言的运算符

C17标准中，C语言总共有48个运算符
```text
算数运算符：+、-、*、/、%、++、--
关系运算符：==、!=、>、>=、<、<=
位运算符：&、|、^、~、<<、>>
赋值运算符：=、+=、-+、*=、/=
逻辑运算符：&&、||、!
成员访问运算符：a[b]、a.b、a->b、&a、*a
其他运算符：sizeof、?:、(type)a、a、...
```

在这些运算符里面
通常来说，算数、关系、位、复制运算符的实现大多数情况下都是与特定的汇编指令一一对应。
逻辑运算符的实现会借助test、cmp等指令，来判断操作数的状态，并在此基础上再进行相应的数值转换过程。
成员访问运算符中，取地址运算符一般对应汇编指令lea，解引用运算符可以通过mov指令来完成。
对于其他运算符，sizeof运算符会在编译的时候进行求值替换，强类型转换则 直接对应于不同指令对同一块数据的不同处理方式。

## 预处理

编译器对代码进行预处理的工作：
1. 删除源代码中的所有注释
2. 处理所有宏定义(#define)，并进行展开和替换
3. 处理所有条件预编译指令(如#if、#elif等)，仅保留符合条件的代码
4. 处理文件包含预编译指令(#include)，将被包含文件的内容插入到该指令的所在位置
5. 处理其他可以识别的预处理指令
6. 添加其他具有辅助性功能的注释信息
...

常用的技巧
1. 为宏函数的返回值添加括号
2. 为宏函函数的参数添加括号
3. 警惕宏函数导致的多次副作用
4. 定义完备的多语句宏函数
...

通常以下三个场景可以是情况选择是否使用预处理器：
1. 定义程序中使用到的魔数，含有某些意义的参数或者常数
2. 基于某些运行环境的条件编译，例如根据不同平台选择不同的执行代码等
3. 封装代码模版，抽取重复代码片段。

## 控制逻辑

### 表达式

表达式有一系列运算符与操作数组成的语法结构，操作数是参与运算符计算的独立单元，也是运算符的操作对象。

对表达式的求值过程，实际上就是根据运算符的优先级和结合性，来对表达式和其它所包含的字表达时进行递归求值的过程。

```c
int main(){
    return (1 + 2) * 3 + 4 / 5;
}
```

借助Clang编译器提供的"-ast-dump"选项编译并打印对应的AST结构

```shell
clang -Xclang -ast-dump -fsyntax-only main.c
```

```text
`-FunctionDecl 0x7fa49e009e00 <main.c:1:1, line:3:1> line:1:5 main 'int ()'
  `-CompoundStmt 0x7fa49e00a038 <col:11, line:3:1>
    `-ReturnStmt 0x7fa49e00a028 <line:2:5, col:30>
      `-BinaryOperator 0x7fa49e00a008 <col:12, col:30> 'int' '+'
        |-BinaryOperator 0x7fa49e009f88 <col:12, col:22> 'int' '*'
        | |-ParenExpr 0x7fa49e009f48 <col:12, col:18> 'int'
        | | `-BinaryOperator 0x7fa49e009f28 <col:13, col:17> 'int' '+'
        | |   |-IntegerLiteral 0x7fa49e009ee8 <col:13> 'int' 1
        | |   `-IntegerLiteral 0x7fa49e009f08 <col:17> 'int' 2
        | `-IntegerLiteral 0x7fa49e009f68 <col:22> 'int' 3
        `-BinaryOperator 0x7fa49e009fe8 <col:26, col:30> 'int' '/'
          |-IntegerLiteral 0x7fa49e009fa8 <col:26> 'int' 4
          `-IntegerLiteral 0x7fa49e009fc8 <col:30> 'int' 5
```

表达式能够让数据同时参与到多个操作数的不同计算过程中。

### 语句

语句用来描述程序的基本构建块，与表达式不同，语句是构成C程序的最大力度单元，在它内部可以包含有简单或复杂的表达式结构，但也可以不包含任何内容。语句都以分号结尾，并按照从上到下的顺序执行。语句分为复合语句、选择语句、表达式语句、迭代语句、跳转语句。

复合语句主要以花括号标记一块区域。
表达式语句直接是由表达式外加一个分号构成的一个语句。
选择语句主要由if...else和switch...case这两种语法结构组成的语句。
迭代语句主要包含do...while、for、while这三种基本语法形式。
跳转语句主要是那些可以改变程序执行流程的语法结构，例如break、continue、return、goto语句。

## C语言函数调用原理

C语言中，函数有两种传递参数的方式，即通过"值"传递和通过"指针"传递。其中值传递的方式，编译器会在函数调用时，传入函数的参数值进行复制，也就是传入的值和实参属于两个不同的实体。通过指针的方式传递本质上通过值传递，传入的是地址，属于两个实体，但是地址指向的值属于同一个实体。

### 函数调用约定

编译器实现函数调用时遵循的一系列规则称为函数的"调用约定"，不同操作系统有不同的编译器对应也有不同的调用约定，在类Unix系统上，则会使用System V AMD64 ABI简称SysV的约定。较为统一的调用约定，一定程度上保证了C程序在同一平台不同编译器的最大可移植性。

以SysV调用约定为例

#### 参数传递

调用函数时，对于整数和指针类型的实参，分别使用寄存器rdi,rsi,rdx,rcx,r8,r9，按照函数定义时从左到右的顺序进行传值。超过6个的参数将会将于下的参数从右向左依次入栈。对于浮点类型的参数，编译器会使用xmm0到xmm07共8个寄存器进行存储。对于更宽的使用ymm与zmm寄存器代替xmm寄存器。

#### 返回值传递

当函数调用产生整数类型的返回值，64位以下的使用rax进行传值。64位以上的使用rax和rdx保存低和高64位。对于复合类型如结构体的返回值编译器可能会直接使用栈内存进行中转。同理对于浮点类型编译器会默认使用xmm0和xmm1存储，返回值过大会使用ymm和zmm。

### 函数调用过程

函数调用一般使用call指令，调用前，先将参数保存到寄存器或者栈，调用时会将下一条的地址压入栈，便于函数调用结束返回回来执行下一条指令，然后调用call指令。被调用函数的第一条指令位push rbp会将当前的rbp值缓存到栈中，接着mov rbp，rsp来开启一个新的栈。执行完函数后，最后通过一条pop指令恢复rbp的值，并通过ret指令将栈中的返回地址弹出到rip中，执行调用时的下一跳指令。


## 整合数据

### 枚举

C标准直接将枚举值当作整数进行处理，如下面foo函数的入参edi寄存器放置0。

```c
typedef enum {
    MON,TUE,WED,THUR,FRI
} Weekday;
void foo(Weekday wd) { }
int main () {
    foo(MON);
    return 0;
}
```
汇编
```text
foo:
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-4], edi
    nop
    pop     rbp
    ret
main:
    push    rbp
    mov     rbp, rsp
    mov     edi, 0
    call    foo
    mov     eax, 0
    pop     rbp
    ret
```

### 结构

数组用来将一簇相同类型的数据存放在连续的内存片段上。而结构体则是存放不同类型。本质上结构体只是对其内部所包含各类数据的一个封装，因此从编译产物的角度看，只需要把它封装的这些数据存放在连续的内存上即可。

内存数据对齐，就是指操作数据的所在地址为该数据大小的整数倍。数据对齐有利于内存读取的效率。

### 联合

联合意味着定义在该数据结构内的所有字段共享同一块内存区域。对于一个联合体来说，其大小与内部定义最大的数据长度的字段一致，同一时刻只能保存一个字段生效。


## C语言中的指针

使用C语法定义变量时，通过为类型说明符添加额外的"*"符号，可以定义一个指向该类型数据的指针。如果额外添加const关键字，还能够限制使用该指针变量时所能够进行的操作类型。

使用运算符"*"(解引用)与"&"(取地址)能够完成指针的最基本操作：赋值与取值。在汇编层面上取地址用lea指令来实现，而解引用通过mov指令完成。

在C语言中，数组有不同的使用方式，有些使用方式可能导致其被退化为相应的指针类型，例如下列代码，指针参与运算，数组arr退化为指针操作，对指针进行相应的运算，而指针的算数运算在绝大多数情况下都只适用于数组相关的指针。数组表示存储在连续存储空间的相同类型的数据。编译器对C代码中的多维数组进行了扁平化处理。
```c
#include <stdio.h>
int main(void) {
    int arr[][] = {{1,2,3},{4,5,6}};
    int a = **(arr+1); // 4
    int b = *(*arr + 2); // 3
}
```

指针给予我们灵活操作内存的能力，指针既可以引用栈内存的数据，也可以引用堆内存中的数据，栈上的数据随着函数的调用与返回会被程序自动释放，而堆进行数数据的分配需要借助特定的操作系统调用函数进行分配与释放，并不会随着程序的运行自动释放。在C中有标准函数库malloc与free来进行堆内存申请与释放。在虚拟地址空间中，栈位于高地址，往低地址延伸。而堆内存的占用区随着程序的不断使用从低地址往高地址增长。


## 标准的IO接口

IO接口也分不同的层次，C语言提供的IO接口属于"标准IO"的范畴，与其相对的则是"低级IO"。顾名思义，低级IO会使用具体的操作系统相关的一系列底层接口来提供相应的IO接口，比如Unix与类Unix操作系统上的POSIX接口标准。与低级IO相比，标准IO会为我们提供带缓冲的输入与输出操作，一般由所使用平台的低级IO来实现的。




## 进程与线程

一般操作系统会为每一个运行中的程序创建一个相应的进程，以作为他的运行实例。进程中包含于该程序有关的一系列运行时信息，如VAS、进程ID、处理器上下文、进程状态等等。这些信息统一放到内核提供的数据结构中，称为“进程控制快PCB，或者程序控制快”。

线程则是程序提供更细粒度的运行单元，绝大多数传统操作系统中每个进程都至少有一个线程。进程负责划分不同程序所享有资源的边界，线程则在共享程序运行资源的情况下，负责程序某个字任务的具体执行过程。此时任务调度将以线程作为最小的调度实体，来加以精细的控制程序的运行。

再多线程环境中，存在三种概念：数据竞争、竞态条件、指令重排。

数据竞争指的是再多线程环境中，两个及以上的线程在同一时间对同一块内存中的数据进行了非原则性操作，且至少有一个是写操作。这种情况下，该数据值的最终状态可能与程序语义上希望表达的计算结果不一致。

竞态条件是指程序中某些事件的发生时机与顺序不一致，从而影响程序运行正确性的一种缺陷。

指令重排是指在尽量不影响程序可观测执行结果下，对生成的指令进行适当的重新排序，以更好的适应处理器的执行效率。







