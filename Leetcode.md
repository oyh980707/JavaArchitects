# Leetcode 算法题总结

## x的平方根

1. 常用的暴力法

2. 袖珍计算器算法

   ```text
   用指数函数 exp 和对数函数 ln 代替平方根函数的方法
   ```

3. 二分查找法

   ```text
   思路：
   1. 设定下界为0，上界为x
   2. 进行二分查找，循环条件为下界必须小于等于上界
   3. 在二分查找的每一步，取中值mid[mid=l+(l-r)/2]，判断mid与x的大小关系
   	1）如果mid小于x，则下界设置为mid
   2）如果mid等于x，则返回结果
   	3）如果mid大于x，则上界设置为mid
   4. 进行下一次循环
   ```

4. 牛顿迭代法

   ```text
   牛顿迭代法是一种可以用来快速求解函数零点的方法。
   用 C 表示待求出平方根的那个整数 y=f(x)=x2−C
   确定初始值 x0 = C
   通过函数的变换，新的迭代结果为xi+1 = 0.5*(xi + c/xi)
   迭代到差值小于某个数时结束，这个数是非负数一般可以取10-6等
   得到的结果就和根接近
   ```

## 爬楼梯

n阶台阶每次走一步或者两步，总共多少种走法，本质上就是一个斐波那契数的求法。

求解方法有很多种：

1. 暴力法：通过递归的方式求解，但是他的时间复杂度O(2的n次方)，空间复杂度是O(n)
2. 对递归方式优化一个记忆数组：采用一个n+1大小的数组保存每次求的值，求过了的值就不用再求了
3. 动态规划：其实就相当于一个滚动数组，运用三个变量依次保存进三次的值来求下一次的值
4. 神奇的让我一头雾水的数学方法求解

总结跳台阶问题的变体题目

- 可一次跳三阶但仅能用一次

解题思路：

1. 给定三个数组

   ```text
   动态规划数组res:res[i]表示到第i层共有多少种合法的走法(“合法的走法”是值至多使用一次一步跳三阶的走法)
   斐波那契数组only2:only2[i]表示完全不用一次跨三阶的走法到第i层有多少种走法(必然全为合法走法)
   特例数组ct3:ct3[i]表示到第i层时一定使用了一次走三阶的所有合法走法
   ```

2. `res[i] = res[i-1] + res[i-2]`动态规划出来的是直接跨一阶和跨两阶的走法，`res[i-3]`表示的是所有的合法走法包括跳一次三阶和不跳三节的走法。`ct3[i-3]`表示的是到i-3层必然跳一次三阶的走法，所以我们现在需要的是到从i-3层到i层为跳一次三阶，所以这个结果为`res[i-3] - ct3[i-3]`

   所以得到最后的动态方程为 `res[i] = res[i-1] + res[i-2] + (res[i-3] - ct3[i-3])`

3. 最后的问题变成推到出ct3，推到出必然有一次跳三阶的次数
   结果为 `ct3[i] = ct3[i-1] + ct3[i-2] + only2[i-3]`
   `only2[i] = only2[i-1] + only[i-2]`

- 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。 

解题思路：

同理可以分析得出：f(n) = f(n-1) + f(n-2) + ... + f(1) 和 f(n-1) = f(n-2) + f(n-3) + ... + f(1)

f(n) = 2f(n-1)

## 杨辉三角

就是一个简单粗暴的解决方法，思路也比较明确，就是对于编程的思维有点死板，思维不灵活，导致做一个简单的算法题需要耗时进一个小时。

杨辉三角只求第k行的结果，就不要额外存储之前的结果了，有以下方法求解：

1. 老办法暴力递推，采用list嵌套list一行一行求出
2. 优化上个方案，只使用两个list保存当前和上一行的list
3. 进一步优化，只使用一个list，通过本身内部的值相互递推出结果(倒着计算当前行的第i项)
4. 线性递推，通过组合通项公式(C<sub>n</sub><sup>m</sup> = C<sub>n</sub><sup>m-1</sup> * (n-m+1/m)，从第n行直接计算整行，时间复杂度为O(n)，空间复杂度O(1)，不包括返回结果

## 买卖股票的最佳时机 II

和买卖股票的最佳时机 I不同的是可以买卖多次，可以采用的方法有以下几种

1. 暴力法（两种买卖股票题都适用）

2. 动态规划（两种买卖股票题都适用，区别点：买卖股票的最佳时机 I：只能买卖一次，所以在每次入股时都是昨天买入股票后手中的现金和当天的股价相反数比较。买卖股票的最佳时机 II：能卖买多次，所以可以和这次买不买股票就看昨天没买股票减去当天股价和昨天买了股票，取大的）

3. 优化动态规划，由于不需要保存很早的历史数据，只需要最近的一次历史数据，可以用滚动数组或者几个变量来滚动保存数据。最终推出结果

   ```text
   买卖股票的最佳时机 II的动态规划思路：
   1. 定义状态
   2. 思考状态转移方程
   3. 确定初始值
   4. 确定输出值
   5. 考虑优化空间
   ```

4. 贪心算法

总结：动态规划有两种求解形式：

- 自顶向下：也就是记忆化递归，求解过程会遇到重复子问题，所以需要记录每一个子问题的结果；

- 自底向上：通过发现一个问题最开始的样子，通过「递推」一步一步求得原始问题的解。

在「力扣」上的绝大多数问题都可以通过「自底向上」递推的方式去做。

## 相交链表

也就是找到两个单链表相交的起始节点。

总结一下方法：

1. 暴力法，直接遍历，时间复杂度O(m*n)
2. 哈希表法，遍历一个链表后保存，然后遍历另一个链表然后哈希表中找有没有存在，存在即是。
3. 最常用的是双指针法，两个指针同时遍历当一指针走到头就指向另一个链表头继续遍历，知道遍历两只节点相等则就是结果，如果没有交叉点，最后两个指针会同时为null。

与此同时也做了几个可以使用双指针的算法题([11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)、[240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/))

## 多数元素

此算法题的解法有很多，但很多方法的时间空间复杂度都是很高
题目：[169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

解题方法：

1. 暴力法：直接统计数组中每个数的数量，时间复杂度O(n^2)
2. 哈希表法：利用哈希表的key保存数，value保存出现的次数，时间空间复杂度都是O(n)
3. 排序：排好序直接取中间数
4. 随机化：随机取个数，然后验证，理论上最坏情况下的时间复杂度为O(∞)
5. 分治：就问题分解成小问题挨个解决，依次分左右两部分统计两边的众数，如果一样则就需要在整个区间进行计算
6. Boyer-Moore 投票算法（推荐使用的算法）：时间复杂度O(n) 空间复杂度O(1)
   1. 我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；
   2. 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：
      1）如果 x 与 candidate 相等，那么计数器 count 的值增加 1；
      2）如果 x 与 candidate 不等，那么计数器 count 的值减少 1。
   3. 在遍历完成后，candidate 即为整个数组的众数。

## 快乐数

「快乐数」定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

我在开始考虑是直接寻找，但是如果不是快乐数我无法终止循环
初步的探索，猜测会有以下三种可能。
1. 最终会得到 1。
2. 最终会进入循环。
3. 值会越来越大，最后接近无穷大。

但是第三种情况我任务不可能发生，在int范围内计算了下最大也不会超过int，所以不会越来越大益处。

题解方法：
1. 哈希集合检测循环：利用Set集合来检测每次计算下一个数后，判断数是否被计算过，如果计算过就会导致循环
2. 快慢指针法：这个和链表检测是否有环一样
3. 数学的方法：统计发现只会最终形成一个环链“4→16→37→58→89→145→42→20→4”，所以只需判断形成的数是否存在这些数中，存在就会存在环，否则就可以形成快乐数





